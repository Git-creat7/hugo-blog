[{"content":"","date":"2026-02-04T18:59:39+08:00","permalink":"/hugo-blog/post/new/","title":"New"},{"content":" imageNameKey: \u0026ldquo;00\u0026rdquo; ","date":"2026-02-03T00:00:00Z","permalink":"/hugo-blog/post/00-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8B%93%E5%B1%95/","title":"00-基础知识拓展"},{"content":"数组 索引 int[] arr = {0, 1, 2, 3, 4}; System.out.println(arr);//[I@f6f4d33 地址符: [ :表示当前是一个数组\nI :表示当前数组里边的元素类型为int\n@ :表示一个间隔符号\n6f4d33 :16进制的数组 ‘地址值’\nint len = arr.length; //获取数组长度 int[] arr = new int [3]; //格式：数据类型[] = new 数据类型[数组长度] 数组默认动态初始化值： 整数类型: 0;\n浮点数类型: 0.0;\n字符类型: \u0026lsquo;/u000\u0026rsquo; (空格)\n布尔类型: false\n引用数据类型: none\nJava内存分配 栈：方法运行时使用的内存，比如main方法运行，进入方法栈中运行。\n堆：存储对象或数组，new来创建的，都存储在堆内存\n方法区：存储可以运行的class文件\n本地方法栈： JVM在使用操作系统的时候使用，和开发无关\n寄存器：给CPU使用，和开发无关\n当两个数组指向同一个小空间时，其中一个数组对小空间中的值发生了改变，那么其他数组再次询问的时候都是修改后的结果了。例如： public static void main(String[] args){ int[] arr1 = {11.22}; int[] arr2 = arr1;//此时arr2与arr1共用一个内存 sout(arr1[0]); //11 sout(arr2[0]); //11 arr2[0] = 33; sout(arr1[0]); //33 sout(arr2[0]); //33 } 方法 方法是程序运行的最小执行单元(类似于c中的函数) 经典例题： 需求：定义一个方法copyOfRange(int[] arr, int from ,int to)\n功能：将数组arr从索引from(包含)开始,到索引to(不包含)的元素复制带一个新的数组中,将新数组返回\npackage test; import java.util.Arrays; import java.util.Scanner; public class method_test { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int[] arr = {1,2,3,4,5}; int[] num = copyOfRange(arr,0,4); //打印新数组num的元素 System.out.println(Arrays.toString(num)); } public static int[] copyOfRange(int[] arr, int from, int to){ //设置数组长度为 from - to int[] num = new int [to - from]; for (int i = from; i \u0026lt; to; i++){ num[i-from] = arr[i]; } return num; } } 传递基本数据类型时，传递的是真实的数据，形参的改变，不影响实际参数的值 public class method_test { public static void main(String[] args) { int num = 100; System.out.println(\u0026#34;调用change方法前\u0026#34; + num); //100 change(num); System.out.println(\u0026#34;调用change方法后\u0026#34; + num); //100 } public static void change(int num){ num = 200; } } 上述代码并未改变number的值，因为方法change()与方法main()存储在栈内存中，两个num并不一样.\n传递引用数据类型时，传递的是地址，形参的该百年，影响实际参数的值 public class method_test { public static void main(String[] args) { int[] arr = {10, 20, 30}; System.out.println(\u0026#34;调用change方法前\u0026#34; + arr[0]); //10; change(arr); System.out.println(\u0026#34;调用change方法后\u0026#34; + arr[0]); //1000; } public static void change(int[] arr){ arr[0] = 1000; } } 上述代码中 arr 数组的值发生了改变，原因是数组属于引用数据类型，其引用(内存地址)存储在栈内存中，而实际数据存储在堆内存中。main 方法与 change 方法共享同一个数组引用(即指向堆内存中同一个数组对象)，因此在 change 方法中对数组内容的修改会影响到 main 方法中访问该数组时的结果\n","date":"2026-02-03T00:00:00Z","permalink":"/hugo-blog/post/01-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","title":"01-基本语法"},{"content":"面向对象 类和对象 类（设计图)：是对象共同特征的描述； 对象：是真实存在的具体东西\n在Java中，必须先设计类，才能获得对象 public class 类名{ 1.成员变量 2.成员方法 3.构造器 4.代码块 5.内部类 } public class Phone{ //属性（成员变量） String brand; double price; //行为（方法） public void call(){ } public void playGame(){ } } 定义类的注意事项\n类名首字母建议大写，需要见名知意 一个Java文件中可以定义多个class类，且只能一个类是public修饰，而且public修饰的类名必须为代码文件名（实际开发中还是建议一个文件定义一个class类） 成员变量完整定义格式是：修饰符 数据类型 变量名称 = 初始化值；一般无需指定初始化值，存在默认值 封装 告诉我们如何正确设计对象的属性和方法\n对象代表什么，就得封装对应的数据，并提供对应的行为 private关键字 是一个权限修饰符 可以修饰成员（成员变量和成员方法） 被private修饰的成员只能在本类中才能访问 以下代码并不安全 public class GirlFriend{ String name; //会出现负数等不合理的值 int age; String gneder; } 修改为以下代码\npublic class GirlFriend{ //将类中的变量转换为私有 private int age; // set 赋值 public void setAge(int a){ if(a \u0026gt;= 18 \u0026amp;\u0026amp; a \u0026lt;= 50){ age = a; }else{ System.out.println(\u0026#34;非法数据\u0026#34;); } } // get 获取 public int getAge(){ return age; } } 就近原则和this关键字 成员变量和局部变量 public class GrilFriend{ private int age;\t//成员变量 public void method(){ int age = 10;\t//局部变量 System.out.println(age);//输出 10 } } 修改为this后可以调用成员变量\npublic class GrilFriend{ private int age;\t//成员变量 public void method(){ int age = 10;\t//局部变量 System.out.println(this.age); } } 构造方法 构造方法也叫做构造器，构造函数 作用：在创建对象的时候给成员变量进行初始化（赋值）。 public class Student(){ 修饰符 类名（参数）{ 方法体; } 特点：\n方法名与类名相同，大小写也要一致\n没有返回值类型，连void也没有\n没有具体的返回值（不能由return带回结果数据） 空参构造：\npublic Student(){ System,out.println(\u0026#34;执行空参构造\u0026#34;)\t} 空参调用：Student s = new Student()\n带参构造：\npublic Student(String name,int age){ System.out.println(\u0026#34;执行带参构造\u0026#34;); this.name = name; this.age = age; } 带参调用：Student s = new Student(\u0026quot;Jim\u0026quot;，18);\n注意事项： 1.构造方法的定义\n如果没有定义构造方法，系统将给出一个默认的无参数的构造方法 如果定义了构造方法，系统将不再提供默认的构造方法 2.构造方法的重载\n带参构造方法和无参构造方法，方法名相同，但是参数不同，这叫构造方法的重载 3.推荐使用方式\n无论是否使用，都手动书写无参数构造方法和带全部参数的构造方法 标准JavaBean 标准的Javabean类 类名需要见名知意 成员变量使用private修饰 提供至少两个构造方法 无参构造方法 带全部参数的构造方法 成员方法 提供每一个成员变量对应的setXxx() / getXxx() 如果还有其他行为，也需要写上 Java内存分配 new 一个对象： 1.加载class文件 2.申明局部变量 3.在堆内存中开辟一个空间 4.默认初始化 5.显示初始化 6.构造方法初始化 7.将堆内存中的地址值赋值给左边的局部变量\nthis本质：代表方法调用者的地址值\nthis作用：区分局部变量和成员变量\n一些实例\u0026hellip; 键盘录入: 第一套体系 (遇到空格,制表符,回车就停止接收)\nnextInt(); //接收整数 nextDouble(); //接收小数 next();\t//接收字符串 第二套体系(遇到回车停止接收)\nnextLine(); //接收字符串 ","date":"2026-02-03T00:00:00Z","permalink":"/hugo-blog/post/02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","title":"02-面向对象"},{"content":"字符串 String 字符串在内存中存储的是地址\n创建String对象的两种方式 １．直接赋值 String name = \u0026quot;MyString\u0026quot;\n2.使用new关键字构造\n//空参构造 String s1 = new String(); // 空 //传递一个字符串，根据传递的字符串内容再创建一个新的字符串对象 String s2 = new String(\u0026#34;abc\u0026#34;); //abc //*传递一个字符数组，根据一个字符数组的内容，创建一个新的字符串 char[] ch = {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;}; String s3 = new String(ch);\t//abcd //*传递一个字节数组，根据一个字节数组的内容，创建一个新的字符串 byte[] bytes = {97,98,99,100}; //传递ASCII码 String s4 = new String(bytes); //abcd 字符串的比较 ​\t先了解\u0026quot;==\u0026ldquo;比较的是什么，在基本数据类型中\u0026rdquo;==\u0026ldquo;比较的是具体的数据值，但是在引用数据类型中，\u0026quot;==\u0026ldquo;比的是地址值，所以在字符串的比较中不能用 \u0026ldquo;==\u0026quot;。\nString s1 = \u0026#34;abc\u0026#34;; String s2 = \u0026#34;abc\u0026#34;; sout(s1 == s2); // true String s1 = new String(\u0026#34;abc\u0026#34;);//记录堆里面的地址值 String s2 = \u0026#34;abc\u0026#34;;\t//记录串池中的地址值 sout(s1 == s2); // false equals 与 equalsIgnoreCase boolean equals 方法：完全一样结果才是true\nboolean equalsIgnoreCase方法：忽略大小写的比较\n（忽略大小写只能是英文状态下的）\nboolean bool = s1.equals(s2)\nScanner sc = new Scanner(System.in); String str1 = sc.next(); //abc String str2 = \u0026#34;abc\u0026#34;;\t//赋值 Souy(str1 == str2) //false [!NOTE]\n两者不一样，键盘录入得到的字符串其实是new出来的，两者的地址值不一样，因此一定要用equals比较字符串\n遍历字符串 public charAt(int index) 根据索引返回字符\npublic int length() 返回此字符串的长度\nString substring(int beginindex, int endlindex) 截取字符串\n[!NOTE] 包头不包尾，包左不包右 ，对原字符拆没影响 重构：String substring (int beginindex) 截取到末尾\n替换字符串 String replace(旧值，新值) 替换 StringBulider 提高字符串的操作效率 StringBuilder 常用方法 public StringBulider() 创建一个空白可变的字符串对象，不含有任何内容 [!NOTE] StringBuilder 是 Java 已经写好的类 Java在底层对他做了一些特殊处理 打印对象不是地址值而是属性值\npublic StringBuilder append(任意类型) 添加数据，返回对象本身\npublic StringBuilder reverse() 反转容器中的内容\npublic int length() 返回长度（字符出现的个数）\npublic String toString() 通过toString()就可以实现把 StringBuilder 转化为 String\n以下是对于StringBuilder 和 toString的演示\n// 此时并不是字符串 StringBuilder sb = new StringBuilder(\u0026#34;abc\u0026#34;); sb.append(\u0026#34;111\u0026#34;); sb.append(\u0026#34;222\u0026#34;); //再将 StringBuilder 变回字符串 String str = sb.toString(); System.out.println(str); [!TIP] 补充 链式编程：当我们在调用一个方法的时候，不需要用变量接收他的结果，可以继续调用其他方法。\n例如：int len getString().substring(1).replace(\u0026quot;A\u0026quot;,\u0026quot;Q\u0026quot;).length()\nStringJoiner StringJoiner 跟 StringBuilder 一样，也可以看成是一个容器，创建之后里边的内容是可变的。 作用：提高字符串的操作效率，而且代码编写特别简介，但是目前市场很少有人用 JDK8才出现 StringJoiner 的构造方法 public StringJoiner(间隔符号) 创建一个StringJoiner对象,指定拼接时的间隔符号 public StringJoiner(间隔符号,开始符号,结束符号) 创建一个StringJoiner对象，指定拼接时的间隔符号,开始符号,结束符号 StringJoiner 的成员方法 public StringJoiner add(添加的内容) 添加数据，并返回数据本身 public int length() 返回长度（字符出现的个数） public String toString() 返回一个字符串（该字符串就是拼接之后的效果） 字符串原理 1.字符串存储的原理 - 直接赋值会复用字符串常量池中的 - new 出来的不会复用，而是开辟一个新的空间\n2.==号比较的到底是什么？ - 基本数据类型 比较数据值 - 引用数据类型 比较地址值\n3.字符串拼接的底层原理\npublic class Test2 { public static void main(String[] args) { String ss = \u0026#34;abc\u0026#34;; // 记录串池中的地址值 String s = \u0026#34;a\u0026#34; + \u0026#34;b\u0026#34; + \u0026#34;c\u0026#34;; //拼接时没有变量,会复用串池中的字符串 System.out.println(s); //abc } } [!NOTE] 拼接的时候没有变量，都是字符串 触发字符串的优化机制 在编译的时候就已经是最终结果了。\n在编译的时候，就会将\u0026quot;a\u0026rdquo;+\u0026ldquo;b\u0026rdquo;+\u0026ldquo;c\u0026rdquo; 拼接为 \u0026ldquo;abc\u0026rdquo;\u0026hellip;\npublic class Test2 { public static void main(String[] args) { String s1 = \u0026#34;a\u0026#34;; String s2 = s1 + \u0026#34;b\u0026#34;; String s3 = s2 + \u0026#34;c\u0026#34;; System.out.println(s3); } } [!NOTE] 相当于先创建了一个new StringBuilder 对象 做完一系列操作后在使用 toString 转化为字符串 new StringBuilder().append(s1).qppend(\u0026ldquo;b\u0026rdquo;).toString();\npublic class Test2 { public static void main(String[] args) { String s1 = \u0026#34;a\u0026#34;; String s2 = \u0026#34;b\u0026#34;; String s3 = \u0026#34;c\u0026#34;; String s4 = s1 + s2 + s3 ; //创建了四个SB对象 System.out.println(s3); } } [!NOTE] JDK8 之前：每次以上的字符串相加都会创建两个SB对象 JDK8 及之后，编译器会对连续的字符串拼接操作进行优化，通过一个StringBuilder完成所有拼接，并预先计算和分配合适的容量，从而减少对象创建和数组扩容的开销。\n总结：\n如果没有变量参与，都是字符串直接相加，编译之后就是拼接的结果，会复用字符串池\n如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存\n4.StringBuilder 提高效率原理图\n所有要拼接的内容都会往StringBuilder中放，不会创建很多无用空间，节约内存 5.StringBuilder 源码分析\n默认创建一个长度为16的字节数组 添加的内容长度小于16，直接存 添加的内容大于16 会扩容（原来的容量*2+2） 如果扩容后还不够，以实际长度为准 补充内容 startsWith(\u0026quot;String\u0026quot;) 或 startsWith(\u0026quot;String\u0026quot;,begin,end)检测字符串（范围）开头\n","date":"2026-02-03T00:00:00Z","permalink":"/hugo-blog/post/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"03-字符串"},{"content":"集合 类似于vector\n[!NOTE] 集合的每个位置存储的是地址值\nArrayList 成员方法（增删改查） boolean add(E e) 添加元素，返回值表示是否添加成功 一般直接用list.add(E e)，因为只要添加就会返回true\nboolean add(E e) 删除指定元素，返回值代表是否删除成功 优先删除索引小的元素\nE remove(int index 删除指定索引的元素，返回被删除的元素\nE set(int index,E e) 修改指定索引下的元素，返回原来的元素\nE get(int index) 获取指定索引的元素\nint size() 集合的长度\n基本数据类型对应的包装类 byte \u0026mdash;\u0026gt; Byte short \u0026mdash;\u0026gt; Short char \u0026mdash;\u0026gt; Character int \u0026mdash; \u0026gt; Integer long \u0026mdash;\u0026gt; Long float \u0026mdash;\u0026gt; Float double \u0026mdash;\u0026gt; Double boolean \u0026mdash;\u0026gt; Boolean ","date":"2026-02-03T00:00:00Z","permalink":"/hugo-blog/post/04-arrlist%E9%9B%86%E5%90%88/","title":"04-ArrList集合"},{"content":"static（静态） 静态变量 在JavaBean中，不加static只能供一个对象使用\n被 static 修饰的变量属于类，所有实例共享同一个变量值 在内存中只存在一份，当类被加载时初始化 通常用于表示所有对象共有的属性 public class Student { // 静态变量（类变量） public static String schoolName = \u0026#34;阳光中学\u0026#34;; // 实例变量 private String name; public Student(String name) { this.name = name; } public static void main(String[] args) { // 直接通过类名访问静态变量 System.out.println(Student.schoolName); // 输出：阳光中学 Student s1 = new Student(\u0026#34;张三\u0026#34;); Student s2 = new Student(\u0026#34;李四\u0026#34;); // 也可以通过实例访问（不推荐） System.out.println(s1.schoolName); // 输出：阳光中学 // 修改静态变量，所有实例都会受到影响 Student.schoolName = \u0026#34;星光中学\u0026#34;; System.out.println(s2.schoolName); // 输出：星光中学 } }\t[!NOTE] JDK8之前，静态区处于方法区里面。 JDK7之后，静态区处于堆空间之中。\n静态方法 多用在测试类和工具类当中 JavaBean中很少用 [!NOTE] JavaBean类：用来描述一类事物的类 测试类：用来检查其他类是否书写正确，带有main方法的类，是程序的入口 工具类：不是用来描述一类事物的，而是帮我们做一些事情的类\n工具类 1.类名见名知意 2.私有化构造方法\npublic class ArrUtil{ private ArrUtil(){} } private ArrayUtil() {} 是一个私有构造方法 由于构造方法被声明为 private（私有），这意味着在类的外部无法调\t用这个构造方法，也就无法创建 ArrayUtil 类的对象实例。 防止这个工具类被意外地实例化\n[!NOTE] 如果不写这个私有构造方法，Java 会默认提供一个公共的无参构造方法 这样别人就可能误将其当作普通 JavaBean，写出new ArrayUtil()这样的代码（虽然创建了对象也没用，但不符合设计意图）\n3.方法定义/为静态\nstatic的注意事项 静态方法只能访问静态变量和静态方法 非静态方法可以访问静态变量或静态方法，也可以访问非静态的成员变量和非静态的成员方法 静态方法中没有this关键字 public class Student{ String name; int age; static String teachername; //this:表示当前方法调用者的地址值 //这个this:是由虚拟机赋值的 public void show1(Student this){//此处的this是虚拟机暗加的 sout(\u0026#34;this:\u0026#34; + this);//地址值 sout(name+\u0026#34;,\u0026#34;+age+\u0026#34;,\u0026#34;+teachername); //实际上是this.name和this.age和this.teachername show2(); //实际上是this.show2(); //意思是当前show1调用的对象继续调用show2 } public void show2(){} poublic static void method(){//此处的静态方法却不会有this关键字 //不可调用非静态的成员变量和成员方法 sout(\u0026#34;静态方法\u0026#34;); } } public class StudentTest(){\tpublic static void main(String[] args){ Student.teachername = \u0026#34;老师姓名\u0026#34;; Student s1 = new Student(); sout(\u0026#34;s1:\u0026#34; + s1);//地址值 s1.name = \u0026#34;张三\u0026#34;; s1.age = 23; s1.show1(); //此处的s1对应this Student s2 = new Stduent(); sout(\u0026#34;s2:\u0026#34; + s2);//地址值 s2.name = \u0026#34;李四\u0026#34;; s2.age = 24; s2.show1();//此处的s2对应this } } 打印后，s1与this的地址值相同，s2与this的地址相同。\n内存的加载 静态：随着类的加载而加载\n非静态：与对象有关\nmain方法 public class HelloWorld{ public static void main(String[] args){ //[]：数组 //String:数据类型 //args：数组名 sout(\u0026#34;HelloWorld\u0026#34;); } } public：被JVM调用，访问权限足够大 static：被JVM调用，不用创建对象，直接类名访问。 因为main方法是静态的，所以测试类中的其他方法也需要是静态的 void：被JVM调用，不需要给JVM返回值 main：一个通用的名称，不是关键字，但是被JVM识别 String[] args：以前用于接受键盘录入数据，现在没用 继承 Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起 继承关系\npublic class Student extends Person{} Studet成为子类（派生类），Person称为父类（基类或超类）。 使用继承的好处： 可以把多个子类中重复的代码抽取到父类中了，提高代码的复用性 子类可以在父类的基础上，增加其他的功能，使子类更强大。 ？什么时候用继承： 当类与类之间，存在相同（共性）的内容，并满足子类是父类的一种，就可以考虑用继承，来优化代码。\n继承特点 Java只支持单继承，不支持多继承，但支持多层继承。\n单继承：一个子类只能继承一个父类 不支持多继承：子类不能继承多个父类 [!NOTE] 每一个类都直接或间接继承于Object\n[!WARNING]\n构造方法不可被继承 成员变量私有和非私有都能被继承（私有不可直接使用） 成员方法只有非私有非static非final（能被加入虚方法表）能被继承 在继承中 成员变量的访问特点 就近原则\npublic class Fu{ String name = \u0026#34;Fu\u0026#34;; } public class Zi extends Fu{ String name = \u0026#34;Zi\u0026#34;;//若没有此语句会打印Fu public void ziShow(){\tString name = \u0026#34;ziShow\u0026#34;;//若没有此语句会打印Zi sout(name); //ziShow...依次向上找name } } public class Fu{ String name = \u0026#34;Fu\u0026#34;; } public class Zi extends Fu{ String name = \u0026#34;Zi\u0026#34;; public void ziShow(){\tString name = \u0026#34;ziShow\u0026#34;; //局部-\u0026gt;本类-\u0026gt;父类 sout(name); //ziShow sout(this.name);//Zi //this:本类 sout(super.name);//Fu //super:父类 } } [!IMPORTANT] name：从局部位置开始往上找\u0026hellip; 局部 \u0026ndash;\u0026gt; 本类 \u0026ndash;\u0026gt; 父类 this.name：从本类成员位置开始往上找\u0026hellip; 本类 \u0026ndash;\u0026gt; 父类 super.name：从父类成员位置开始往上找\u0026hellip;父类\n在继承中成员方法的访问特点 直接调用满足就近原则，super调用直接访问父类 方法的重写： 当父类的方法不能满足子类现在的需求时，需要进行方法重写\n书写格式： 在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。 @Override重写注解 @Override是放在重写后的方法上，校验子类重写时语法是否正确。\n方法重写的本质 A类\u0026mdash;\u0026mdash;-继承\u0026mdash;\u0026mdash;\u0026gt;B类\u0026mdash;继承\u0026mdash;\u0026gt;C类\n子类覆盖了从父类继承下来的虚方法表里的方法\n写入方法 A（method2） B（method2） C（method1，method2） 虚方法表 C：method1 C：method1 C：method1 A：method2（）重写 B：method2（重写） C：method2 [!NOTE] 1.重写方法的名称、形参列表必须与父类中的一致 2.子类重写父方法时.，访问权限子类必须大于等于父类（空 \u0026lt; protected \u0026lt; public） 3.子类重写父类方法时，返回值类型必须小于等于父类 4.重写的方法尽量和父类保持一致 5.只有被添加到虚方法表中的方法才能被重写\n在继承中构造方法的访问特点 父类中的构造方法不会被子类继承，但是可以使用super调用。 子类中所有的构造方法默认先访问父类中的无参构造，在执行自己。（子类构造方法第一句默认是super()，不写也存在，若想调用父类有参构造，则必须使用super） 如果想要访问父类的有参构造，必须手动书写 this 与 super this:理解为一个变量，表示当前方法调用者的地址值。 super:代表父类存储空间。\n关键字 访问成员变量 访问成员方法 访问构造方法 this this.成员变量\u0026mdash;访问本类成员变量 this.成员方法\u0026mdash;访问本类成员方法 this(\u0026hellip;)\u0026mdash;访问本类构造方法 super super.成员变量\u0026mdash;访问父类成员变量 super.成员方法\u0026mdash;访问父类成员方法 super(\u0026hellip;)\u0026mdash;访问父类构造方法 this()：\n[!NOTE] 在子类中可以直接快捷使用构造函数\nclass Student{ String name; int age; String school; Student(){ //表示调用本类的其他构造方法 //虚拟机不会再添加super(); this(null,0,\u0026#34;默认大学\u0026#34;); } public Student(String name, int age, String school) { //因为调用之后此处有一个super(); this.name = name; this.age = age; this.school = school; } } 多态 同类型的对象，表现出不同的形态 表现形式：父类类型 对象名称 = 子类对象; 前提： 1.有继承/实现关系\n2.有父类引用指向子类对象\n3.有方法重写\n好处：使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利。\npublic class Test { public static void main(String[] args) { Student s = new Student(\u0026#34;张三\u0026#34;,18); Teacher t = new Teacher(\u0026#34;王建国\u0026#34;,22); Admin a = new Admin(\u0026#34;管理员\u0026#34;,20); register(s); register(t); register(a); } //接收老师，学生，管理员 public static void register(Person p){ //在每一个子类中都重写了show方法 //p.show()，会直接指向子类的方法 p.show(); } } 多态调用成员变量的特点 `父类类型 对象名称 = 子类对象;` 变量调用：编译看左边，运行也看左边 //Animal 默认name为\u0026#34;动物\u0026#34; //Dog 默认name为\u0026#34;狗\u0026#34; Animal a = new Dog(); //编译看左边：Javac编译代码的时候，会看左边的父类有没有这个变量，如果有，编译成功，反之失败 //运行也看左边：Java运行代码的时候，实际获取的就是左边父类中成员变量的值 sout(a.name);//动物 方法调用：编译看左边，运行看右边 Animal a = new Dog(); //编译看左边：Javac编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，反之失败 //运行看右边：Java运行代码的时候，实际上运行的是子类中的方法 a.show();//Dog---show方法 [!NOTE] 成员变量：在子类的对象中，会把父类的成员变量也继承下来。父：name，子：name（本质上时在内存中开辟了一个地址空间存储两个name） 成员方法：如果子类对方法进行了重写，那么在虚方法表中是会把父类的方法进行覆盖。\n优点：使用父类型作为参数，可以接收所有子类对象\n弊端：不能调用子类的特有功能（方法），但是可以通过强制转换解决\nAnimal a = new Dog(); Dog d = (Dog)a;//大范围 -\u0026gt; 小范围\t//判断对象是不是某一个类中的 instanceof if(a instanceof Dog){ Dog d = (Dog)a; d.lookHome(); }else if{ Cat c = (Dog)a; c.catchMouse(); }else{ sout(\u0026#34;没有这个类型，无法转换\u0026#34;); } //新特性 if(a instanceof Dog d){ //\tDog d = (Dog)a; d.lookHome(); }else if(a instanceof Cat c){ //\tCat c = (Dog)a; c.catchMouse(); }else{ sout(\u0026#34;没有这个类型，无法转换\u0026#34;); } 包 包就是文件夹，用来管理不同类的Java类，方便后期代码维护 包名一般都用小写 使用其他类的规则： 1.使用同一个包中的类时，不需要导包\n2.使用Java.lang包中的类时，不需要导包\n3.其他情况都需要导报\n4.如果同时使用两个包的同名类，需要用 全类名\n全类名：包名 + 类名\nfinal 方法：表明该方法时最终方法，不能被重写\n类：表明该类是最终类，不能被继承\n变量：叫做常量，只能被赋值一次 (c/c++中的const)\n[!TIP] 常量的命名规范 单个单词：全部大写 多个单词：全部大写，单词之间用下划线隔开\n[!NOTE] final修饰的变量是基本类型：那么变量存储的数据值不能发生改变\nfinal修饰的变量是引用类型：那么变量存储的地址值不能发生改变，对象内部的可以改变（静态指针）\n//记录的地址值不能发生改变 final Student S = new Student(\u0026#34;张三\u0026#34;,23); //\tS = new Student(); ！报错 S.setName(\u0026#34;李四\u0026#34;); // 对象内部可以改变 补充：字符串不可变的原因是String是由final和private存储的数组\n权限修饰符 控制一个成员能够被访问的范围 可以修饰成员变量，方法，构造方法，内部类。 修饰符 同一个类中 同一个包中其他类 不同包下的子类 不同包下的无关类 private √ 空着不写（默认） √ √ protected √ √ √ public √ √ √ √ 代码块 构造代码块：从多个构造方法中抽取重复代码，而且会先于构造方法的执行\n静态代码块 格式：static{} 特点：需要static关键字修饰，随着类的加载而加载，并且自动触发，只执行一次。\nstatic{ sout(\u0026#34;执行静态代码块\u0026#34;); //随着类的加载而加载，并且只执行一次。 } 应用：数据初始化\n//sattic里面只能用static static ArrayList\u0026lt;Student\u0026gt;list = new ArrayList\u0026lt;\u0026gt;(); static{ sout(\u0026#34;初始化\u0026#34;); } public staic void main(String[] args){ ... } 抽象类和抽象方法 抽象类: 是一种不能被实例化的类，它主要用于定义其他类（子类）的共同接口和部分实现.\n抽象方法一定在抽象类中 抽象类不一定含有抽象方法. 抽象类的主要特点： 1.不能实例化：抽象类本身不能创建对象，只能作为父类被继承\n2.可以包含抽象方法：抽象方法只有声明，没有具体实现，必须由子类实现\n3.可以包含具体方法：抽象类也可以有已实现的方法，供子类直接使用或重写\n4.子类必须实现所有抽象方法：如果子类没有实现父类的所有抽象方法，那么子类也必须是抽象类\n接口 接口用关键字**interface**来定义\npublic interface 接口名{} 接口不能实例化 接口和类之间是实现关系，通过**implements**关键字表示\npublic class 类名 implement 接口名{} 接口的子类（实现类） 要么重写接口中的所有抽象方法 要么是抽象类 [!NOTE] 1.接口和类的实现关系，可以单实现，也可以多实现。 public class 类名 implements 接口名1，接口名2{} 2.实现类还可以在继承一个类的同时实现多个接口。 public class 类名 extends 父类 inplements 接口名1，接口名2{}\n成员特点和接口中的各种关系 接口中成员的特点\n成员变量\n只能是常量 默认修饰符：public static final\n构造方法：没有\n成员方法 只能是抽象方法 默认修饰符：public abstract\nJDK7以前：接口中只能定义抽象方法\nJDK8的新特性：接口中可以定义有方法体的方法\nJDK9的新特性：接口中可以定义私有方法\n接口和类的关系 类和类的关系 继承关系，只能单继承，不能多继承，但是可以多层继承\n类和接口的关系 实现关系，可以单实现，也可以多实现，还可以在继承一个类同时实现多个接口\n接口和接口的关系 继承关系，可以单继承，也可以多继承\n接口中的默认方法 格式： public default 返回值类型 方法名（参数列表）{\t}\n接口中默认方法的注意事项 1.默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字\n2.public可以省略，default不能省略\n3.如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写。\n接口中的静态方法 JDK8以后 允许在接口中国定义静态方法，需要用static修饰 接口中静态方法的额定义格式 ：\n-　格式:\tpublic static 返回值类型　方法名（参数列表）{ }\n-　范例:\tpublic static void show(){ }\n注意事项：\n静态方法只能通过接口名调用，不能同故宫实现类名或者对象名调用\npublic可以省略，static 不可以省略\nJDK9以后 接口中出现了私有方法\nprivbate 返回值类型 方法名（参数列表）{} private void show(){ } private static 返回值类型 方法名（参数列表）{} private static void method(){ } public interface InterA { public static void show1(){ System.out.println(\u0026#34;show1方法开始执行了\u0026#34;); show3(); } public static void show2(){ System.out.println(\u0026#34;show2方法开始执行了\u0026#34;); show3(); } public static void show3(){ //必须是static //若上述show1,show2是default，则不需要static System.out.println(\u0026#34;记录程序运行时的各种细节\u0026#34;); } } [!NOTE] 静态的私有方法，为静态方法服务 普通的私有方法，为默认方法服务\n接口的应用（接口多态） 接口类型 j = new 实现类对象(); 编译看左，运行看右\n适配器设计模式 设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。 使用设计模式是为了可重用代码、让代码更容易被他人理解，保证代码的可靠性、程序的重用性。（设计模式就是多种套路） 适配器设计模式：解决接口与接口实现类之间的矛盾问题 public interface Inter { public abstract void method1(); public abstract void method2(); ... public abstract void method10(); } //在此创建父类来使InterImpl更加简洁 public abstract class InterAdapter implements Inter { //abstract 不让外界创建对象 @Override public void method1() {} public void method2(); ... @Override public void method10() {} } public class InterImpl extends InterAdapter{ //需要用到哪个方法就重写哪个方法 @Override public void method5() { System.out.println(\u0026#34;第五个方法\u0026#34;); } } Inter定义了多个抽象方法，但是测试类只需要调用其中的一个方法method5()，于是添加一个类（作为测试类的父类）去重写所有方法，这样测试类就可以按需重写方法了。其中添加的这个类就是适配器\n内部类 类的五大成员：属性，方法，构造方法，代码块，内部类 内部类分为： 成员内部类，静态内部类，局部内部类，匿名内部类 在A类的内部定义B类，B类就被成为内部类 内部类表示的事物是外部类的一部分，内部类单独出现没有任何意义 访问特点\n内部类可以直接访问外部类的成员，包括私有private 外部类要访问内部类的成员，必须创建对象。 成员内部类 写在成员位置的，属于外部内部类 成员内部类可以被一些修饰符修饰，private、默认、protected、public、static等（用static修饰就是静态内部类了） 获取成员内部类对象的两种方式：\n方式一：外部类编写方法，对外提供内部类对象\n方式二：直接创建\n格式 Outer.Inner oi = new Outer().new Inner();\n成员内部类获取外部类的成员变量\npublic class Outer { private int a = 10;//\u0026lt;----sout(Outer.this.a) class Inner { private int a = 20;//\u0026lt;----sout(this.a) private void show() { int a = 30;//\u0026lt;----sout(a) System.out.println(a); System.out.println(this.a); System.out.println(Outer.this.a);//此处的Outer是类名 } } } 静态内部类 是用static修饰的成员内部类 静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象 创建静态内部类对象的格式： 外部类名.内部类名. 对象名 = new 外部类名.内部类名 (); Outer.Inner oi = new Outer.Inner();\n调用非静态方法的格式：\n先创建对象，再对象调用\n调用静态方法的格式：\n外部类名.内部类名.方法名();\n局部内部类（了解） 1.将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量 2.外界是无法直接使用，需要在方法内部创建对象使用 3.该类可以直接访问外部类的成员，也可以访问方法内的局部变量 匿名内部类** 匿名内部类本质上是隐藏了名字的内部类 new 类名或接口名(){ 重写方法; }; //注意有分号 接口（实现关系） public class Student implements Swim(){\t@Override public void swim(){ sout(\u0026#34;重写的swim方法\u0026#34;); } } //1.把前面的class去掉，剩余的内容变成了一个没有名字的类 //2.这个没有名字的类想要实现Swim接口 //把Swim写在了大括号的前面，表示这个没有名字的类实现了Swim接口，所以需要在类中重写接口里面的所有抽象方法。 new Swim(){ @Override public void swim(){ sout(\u0026#34;重写的swim方法\u0026#34;) } //这一部分(匿名内部类的对象)是没有名字的类(Student)，他来实现Swim接口 }; 类名（继承关系） new Animal(){ @Override public void eat(){ sout() } } 应用/拓展\npublic class Test { public static void main(String[] args) { //整体理解为Swim接口的实现类对象 //接口多态：接口类型 j = new 实现类对象(); Swim s = new Swim(){ @Override public void swim() { System.out.println(\u0026#34;重写之后的swim方法\u0026#34;); } }; //编译看左边，运行看右边 s.swim(); new Swim(){ @Override public void swim() { System.out.println(\u0026#34;重写之后的swim方法\u0026#34;); } }.swim();//自己调用自己 } } 格式的细节： 包含了继承或实现，方法重写，创建对象。整体就是一个类的子类对象或者接口的实现类对象 使用场景： 当方法的参数是接口或者类时。 以接口为例，可以传递这个接口的实现类对象 如果实现类只要使用一次，就可以用匿名内部类简化代码\n","date":"2026-02-03T00:00:00Z","permalink":"/hugo-blog/post/05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/","title":"05-面向对象进阶"},{"content":"API 应用程序编程接口\nAPI就是别人写好的东西，我们不需要自己编写，直接使用即可 例如： Random r = new Random();\nScanner sc = new Scanner();\nJava API：JDK中提供的各种功能的Java类 System public static void exit(int status) 终止当前运行的Java虚拟机 public static long currentTimeMillis() 返回当前系统的时间（毫秒） public static void arraycopy(数据源数组,起始索引,目的地数组,起始索引,拷贝个数) 数组拷贝 （地址值）\nRuntime Runtime表示当前虚拟机的运行环境\npublic static\tRuntime getRuntime() 当前系统的运行环境对象\npublic void exit(int status)\t停止虚拟机\npublic int availableProcessors()\t获取CPU线程数\npublic long maxMemory()\tJVM能从系统中获取总内存大小byte\npublic long\ttotalMemory()JVM已经从系统中获取总内存大小byte\npublic long freeMemory() JVM剩余内存大小byte public Process exec(String command)\t运行cmd命令\nObject public boolean\tequals(Objects obj) 比较地址值\npublic String toString() 返回对象的字符串表示形式\nprotected object clone(int a) 对象克隆\nString s = \u0026#34;abc\u0026#34;; StringBuilder sb = new StringBuilder(\u0026#34;abc\u0026#34;); System.out.println(s.equals(sb));//false *String中的equals方法会先判断参数是否为字符串* *是字符串再比较内部属性* System.out.println(sb.equals(s));//false *StringBuilder仅比较地址值* (String) public boolean equals(Object anObject) { if (this == anObject) { return true; } return (anObject instanceof String aString) \u0026amp;\u0026amp; (!COMPACT_STRINGS || this.coder == aString.coder) \u0026amp;\u0026amp; StringLatin1.equals(value, aString.value); } (StringBuilder{Object的方法}) public boolean equals(Object obj) { return (this == obj); } 克隆clone 对象克隆：把A对象的属性值完全拷贝给B对象，也叫对象拷贝，对象复制\n第一种克隆方式（浅克隆） 不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来 Cloneable 如果一个接口里面没有抽象方法，表示当前的接口是一个可标记接口，现在Cloneable表示一旦实现了那么当前的对象就可以被克隆 如果没有实现，当前类的对象就不能克隆 public static void main(String[] args) throws CloneNotSupportedException { Student s1 = new Student(\u0026#34;zhangsan\u0026#34;,18); Object s2 = (Student)s1.clone(); System.out.println(s1);//@23fc625e System.out.println(s2);//@3f99bd52 System.out.println(s1 == s2);//false } @Override（写在JavaBean中） protected Object clone() throws CloneNotSupportedException { return super.clone(); } /*\t1.重写Object中的clone方法 2.让JavaBean类实现Cloneable接口 3.创建原对象调用clone\t*/ [!NOTE] 浅克隆（引用数据类型）用的是相同的地址值，当其中一个对象修改该引用类型字段的内容时 另一个对象也会受到影响，可能导致数据不一致的问题。\n第二种克隆方式（深克隆） 基本数据类型拷贝过来 字符串复用 引用数据类型会重新创建新的 [!NOTE] 基本数据类型 ： 直接克隆对象 引用数据类型 ： 创建一个新的对象 注：String 深克隆时用串池地址（原地址），只有在改变后才会创建新String对象，因为String本身不可变 此时的data记录新数据的地址值\nObjects public static boolean equals(Object a,Object b)先做非空判断，比较两个对象\npublic static boolean isNull(Object obj)判断对象是否为null，null-\u0026gt;true\npublic static boolean nonNull(Object obj)判断对象是否为null，与isNull的结果相反\nimport java.util.Objects; public class TestDemo { public static void main(String[] args) throws CloneNotSupportedException { Student s1 = null; var s2 = new Student(\u0026#34;zhangsan\u0026#34;,23); boolean res = Objects.equals(s1,s2); System.out.println(res); //方法的底层会判断n1 ?= null，如果为null，直接返回false //如果s1不为null，那么就利用s1再次调用equals方法 //此时s1是Student类型，所以最终还是会调用Student中的equals方法 //未重写-\u0026gt;比较地址值 重写-\u0026gt;比较属性值 } } BigInteger和BigDecimal BigInteger的构造方法 public BigInteger(int num,Random rnd)获取随机大整数，范围:[0~2的num次方-1]\npublic BigInteger(String val) 获取指定的大整数\npublic BigInteger(String val,int radix)获取指定进制的大整数\npublic static BigInteger valueOf(long val)静态方法获取BigInteger的对象，内部有优化(-116,116)\n[!NOTE] 对象一旦创建，内部的数据不能发生改变\nBigInteger bd1 = new BigInteger.valueOf(1); BigInteger bd2 = new BigInteger.valueOf(2); BigInteger res = bd1.add(bd2);//产生一个新对象 //res = 3; BigInteger的成员方法 BigDemical 常用方法\n表示的数字不大(没有超出double) -\u0026gt; 使用静态方法 public static BigDecimal valueOf(double val) 表示的数字比较大(超出double) -\u0026gt; 使用构造方法 BigDecimal bd = new BigDecimal(String val) [!NOTE] 如果传递的是[0,10]之间的数，那么方法会返回已经创建好的对象（不会new）\n[!NOTE] 注：divide除法方法必须除尽，否则会报错\n舍入模式 说明 UP 远离0方向舍入的舍入模式(\u0026lt;- -\u0026gt;) DOWN 靠近0方向舍入的舍入模式(-\u0026gt; \u0026lt;-) CEILING 向正无穷大方向舍入（ -\u0026gt; ） FLOOR 向负无穷大方向舍入 ( \u0026lt;- ) HALF_UP 四舍五入 正则表达式（regex） (?i)abcd会忽略abcd的大小写 a(?i)bcd会忽略bcd的大小写 a((?i)b)cd会忽略b的大小写 Date时间类 //简单时间类 Date d1 = new Date();//获取当前时间 Date d2 = new Date(0L)//获取初始时间+0ms后的时间Thu Jan 01 08:00:00 CST 1970 d2.getTime().sout;//0 Date d3 = new Date(1000L)//获取初始时间+1000ms后的时间Thu Jan 01 08:00:01 CST 1970 d3.getTime().sout;//1000 SimpleDateFormat类 format格式化：把时间转换成指定格式 parse解析：把字符串表示的时间变成Date对象 构造方法 ==public SimpleDateFormat() 使用默认格式== SimpleDateFormat sdf = new SimpleDateFormat(); Date date = new Date(0L); String str = sdf.format(date); System.out.println(str); 默认格式：1970/1/1 08:00 ==public SimpleDateFormat(String Pattern) 使用指定格式== SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy年MM月dd日 HH:mm:ss EEEE\u0026#34;); Date date = new Date(0L); String str = sdf.format(date); System.out.println(str); 指定格式：1970年01月01日 08:00:00 星期四 字母 描述 (Description) 示例 (Output) 备注 (Note) G 年代标志 (Era) AD (公元) 通常用于历史日期 y 年 (Year) 2026; 26 yy 是两位年，yyyy 是四位年 u 纪元年 (Year) 2026 在 java.time 中比 y 更严谨 M 月份 (Month) 07; Jul; July 大写；MM 为数字，MMM 为缩写 L 独立月份 (Month) 7; July 常用于特定语言环境的格式化 d 月中天数 (Day) 10; 05 小写；该月中的第几天 D 年中天数 (Day) 189 该年中的第几天 (1-366) E 星期 (Day in week) Tue; Tuesday 星期几的文本描述 e 星期数字 (Day of week) 2 1 (周一) 到 7 (周日) a 上下午标记 (AM/PM) PM 上午或下午 H 24小时制小时 0-23 大写；常用于服务器日志 h 12小时制小时 1-12 小写；需配合 a 使用 m 分钟 (Minute) 30 小写；不要和月份 M 搞混 s 秒 (Second) 55 秒数 S 毫秒 (Fraction) 978 毫秒或纳秒的零头 n 纳秒 (Nano) 500000 仅限 Java 8+ 的 java.time z 时区 (Time Zone) CST; PST 通用时区名称 Z 时区偏移 (Offset) +0800 RFC 822 格式 X ISO 8601 时区 Z; +08; +08:00 现代 API 推荐使用的时区格式 常用方法 ==public final String format(Date date) 格式化（日期对象 -\u0026gt; 字符串)== ==public Date parse(String source) 解析（字符串 -\u0026gt; 日期对象）== Calendar类 Calendar代表了系统当前时间的日历对象，可以单独修改、获取事件中的年月日 Calendar是一个抽象类，不能直接创建对象，需要通过一个静态方法获取到子类对象 get/set/add方法 Calandar c = Calandar.getInstance(); c.get(Calandar.YEAR); c.set(Calandar.YEAR,11)//实际为12月 c.add(Calandar.YEAR,1)//实际为次年1月 数字 常量名 含义 注意事项 1 Calendar.YEAR 年 - 2 Calendar.MONTH 月 从 0 开始。0表示1月，11表示12月。 5 Calendar.DATE / DAY_OF_MONTH 日 两个常量效果一样。 10 Calendar.HOUR 小时 12小时制。 11 Calendar.HOUR_OF_DAY 小时 24小时制。 12 Calendar.MINUTE 分钟 - 13 Calendar.SECOND 秒 - 7 Calendar.DAY_OF_WEEK 星期 周日是1，周一是2，周六是7。 LocalDateTime 包装类 基本数据类型所对应的对象 Integer Integer缓存 Java的Integer类内部实现了一个静态缓存池，用于存储特定范围内的整数值对应的Integer对象。 默认情况下，这个范围时-128至127。当通过Integer.valueOf(int)方法创建一个在这个范围内的整数对象时，并不会每次都生成新的对象实例，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象。 目的：节约内存 JDK5以后 自动装箱、自动拆箱 直接赋值获取对象 计算时不需要new，不需要调用方法，直接赋值即可 Integer i1 = 10; Integer i2 = 20; Integer i3 = i1 + i2;//底层：先拆箱 -\u0026gt; 计算 -\u0026gt; 再装箱赋值给i3 Integer成员方法 Arrays Arrays.binarySearch() 查找的元素存在，就返回真实的索引 查找的元素不存在，就返回( -插入点 - 1 ) int[] a = {1,2,3,4,5,6,7,8,9,10}; Arrays.binarySearch(arr,10);//9 Arrays.binarySearch(arr,100)//-11 Arrrays.copyOf() if(新数组len \u0026lt; 老数组len) 会部分拷贝 if(新数组len = 老数组len) 会完全拷贝 if(新数组len \u0026gt; 老数组len) 会补上默认初始值(int[] 补0) int[] a = {1,2,3,4,5,6,7,8,9,10}; int[] newa = Arrays.copyOf(a); Arrrays.copyOfRange() 包左不包右（左闭右开） int[] a = {1,2,3,4,5,6,7,8,9,10}; int[] newa = Arrays.copyOfRange(a,0,9); //1 2 3 4 5 6 7 8 9 Arrays.fill() int[] a = {1,2,3,4,5,6,7,8,9,10};\tArrays.fill(a,100);//100 100 100 ... Arrays.sort() 对基本类型快速排序 Arrays.sort(a);//升序 重载 只能对引用数据类型排序 o1：表示在无序序列中，遍历得到的每一个元素 o2：表示有序序列中的元素 返回值 负数：表示当前要插入的元素是小的，放在前面 正数：表示当前要插入的元素是大的，放在后面 0 ：一样大，放在后面 Integer[] a = {2,7,5,4,5,6,7,8,9,31}; Arrays.sort(a,newComparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { return o1-o2; } }); Lambda表达式 ( )对应方法的形参 -\u0026gt; 固定格式 { } 对应方法体 Integer[] a = {2,7,5,4,5,6,7,8,9,31}; Arrays.sort(a,(Integer o1, Integer o2) -\u0026gt; { return o1-o2; } ); \u0026gt;[!NOTE] \u0026gt;lambda 表达式可以用来简化匿名内部类的书写（不是所有） \u0026gt;lambda 表达式只能简化函数式接口的匿名内部类写法 \u0026gt; \u0026gt;函数式接口： \u0026gt;- **有且仅有一个抽象方法的接口**，接口上方可以加@FunctionalInterface的注解 ```Java Integer[] a = {2,7,5,4,5,6,7,8,9,31}; Arrays.sort(a,(Integer o1, Integer o2) -\u0026gt; { return o1-o2; } ); package MyTestDemo2; public class TestDemo{ public static void main(String[] args){ method(()-\u0026gt;{ System.out.println(\u0026#34;lambda:\u0026#34;); System.out.println(\u0026#34;swimming\u0026#34;); }); } public static void method(swim s){ s.swimming(); } } @FunctionalInterface interface swim{ public void swimming(); } 可推导，可省略 Integer[] a = {2,7,5,4,5,6,7,8,9,31}; Arrays.sort(a,(o1,o2) -\u0026gt; o1-o2);//升序 Arrays.sort(a,(o1,o2) -\u0026gt; o2-o1);//倒序 ","date":"2026-02-03T00:00:00Z","permalink":"/hugo-blog/post/06-api/","title":"06-API"},{"content":"插值查找 前提是数据有顺序 int[] list = {7,23,79,81,103,127,131,147}; int l = 0; int r = list.length - 1; int x = sc.nextInt(); int mid; while (l \u0026lt;= r \u0026amp;\u0026amp; x \u0026gt;= list[l] \u0026amp;\u0026amp; x \u0026lt;= list[r]) { // 先乘后除 mid = l + (x - list[l]) * (r - l) / (list[r] - list[l]); if (x == list[mid]) { System.out.println(\u0026#34;找到了，索引为：\u0026#34; + mid); break; } else if (x \u0026gt; list[mid]) { l = mid + 1; } else { r = mid - 1; } } 插值查找优点：对于均匀分布的数组，速度极快（时间复杂度接近 $O(\\log(\\log n))$）。 插值查找缺点：如果数据分布极不均匀（比如：{1, 2, 3, 100, 1000, 10000}），插值查找的性能可能还不如二分查找。 冒泡排序 相邻的数据两两比较 if(a[i] \u0026gt; [j]) swap(a[i],a[j]) 选择排序 从0索引开始，拿着每一个索引上的元素跟后面的元素一一比较，小的放前面，大的放后面。 第一轮循环，确定确定了最小元素 插入排序 分为有序组和无序组 将无序组逐个插入有序组中 public class TestDemo { public static void main(String[] args) { int[] arr = {4,16,5,9,12,21,18, 32,23,37,26,45,34, 50,48,61,52,73,66}; int startIndex = -1; for (int i = 0; i \u0026lt; arr.length; i++) { if(arr[i] \u0026gt; arr[i+1]){ startIndex = i + 1; break; } } if(startIndex == -1){ return ; } for(int i = startIndex; i \u0026lt; arr.length; i++){ int j = i; while(j \u0026gt; 0 \u0026amp;\u0026amp; arr[j] \u0026lt; arr[j-1]) {//寻找正确的位置 int temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; j--; } } } } 递归 方法再次调用方法本身 递归一定要有出口，否则就会内存溢出 快速排序 第一轮：将0索引数字作为基准数，确定基准数在数组中的正确位置 // 快速排序主方法：递归分治 private static void quickSort(int[] a, int l, int r) { if(l \u0026lt; r){ int mid_index = find(a,l,r); // 分区，返回基准值的正确索引 quickSort(a,l,mid_index-1); // 排序左子数组（小于基准） quickSort(a,mid_index+1,r); // 排序右子数组（大于基准） } } // 分区函数：选a[l]为基准，返回基准值的最终索引 private static int find(int[] a, int l, int r) { int pivot = a[l]; // 基准值（保存副本，避免被修改） int left = l + 1; // 左指针：从基准下一位开始找大于pivot的元素 int right = r; // 右指针：从右边界开始找小于pivot的元素 while (true) { // 右指针找小于基准值的元素（left\u0026lt;=right 防止越界） while (left \u0026lt;= right \u0026amp;\u0026amp; a[right] \u0026gt;= pivot) { right--; } // 左指针找大于基准值的元素（left\u0026lt;=right 防止越界） while (left \u0026lt;= right \u0026amp;\u0026amp; a[left] \u0026lt;= pivot) { left++; } // 左指针超过右指针，分区结束 if (left \u0026gt; right) { break; } // 交换左右指针指向的元素（真正修改数组） int temp = a[left]; a[left] = a[right]; a[right] = temp; } // 把基准值放到正确位置（right是小于基准区域的最后一位） int temp = a[l]; a[l] = a[right]; a[right] = temp; return right; // 返回基准值的最终索引 } ","date":"2026-02-03T00:00:00Z","permalink":"/hugo-blog/post/07-%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/","title":"07-基本算法"},{"content":" imageNameKey: \u0026ldquo;08\u0026rdquo; Collection 接口（单列集合根接口） ├─ List 接口（有序、可重复） │ ├─ ArrayList（实现类）：动态数组，查询快、增删慢 │ ├─ LinkedList（实现类）：双向链表，增删快、查询慢 │ └─ Vector（实现类）：动态数组，线程安全、性能差 └─ Set 接口（无序、不可重复） ├─ HashSet（实现类）：哈希表，无序去重 ├─ TreeSet（实现类）：红黑树，排序去重 └─ LinkedHashSet（实现类）：哈希表+链表，有序去重 flowchart TD A[Collection\u0026lt;br/\u0026gt;（单列集合根接口）] --\u0026gt; B[List\u0026lt;br/\u0026gt;（有序、可重复）] A --\u0026gt; C[Set\u0026lt;br/\u0026gt;（无序、不可重复）] B --\u0026gt; B1[ArrayList\u0026lt;br/\u0026gt;（动态数组）] B --\u0026gt; B2[LinkedList\u0026lt;br/\u0026gt;（双向链表）] B --\u0026gt; B3[Vector\u0026lt;br/\u0026gt;（线程安全数组）] C --\u0026gt; C1[HashSet\u0026lt;br/\u0026gt;（哈希表）] C --\u0026gt; C2[TreeSet\u0026lt;br/\u0026gt;（红黑树）] C1 --\u0026gt; C3[LinkedHashSet\u0026lt;br/\u0026gt;（哈希表+链表）] %% 样式优化（可选） A:::root B:::subInterface C:::subInterface B1:::impl B2:::impl B3:::impl C1:::impl C2:::impl C3:::impl classDef root fill:#f9f,stroke:#333,stroke-width:2px classDef subInterface fill:#9ff,stroke:#333,stroke-width:2px classDef impl fill:#ff9,stroke:#333,stroke-width:1px Collection Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的\nCollectio是一个接口，不能直接创建它的对象，只能创建实现类的对象\n[!WARNING] contains方法在底层依赖equals方法\n如果是自定义对象，那么必须在JavaBean重写equals方法\n遍历 迭代器遍历 Iterator\u0026lt;E\u0026gt; iterator() 返回迭代器对象，默认指向当前集合的0索引\nboolean hasNext() 判断当前位置是否有元素\nE next() 获取当前位置元素，并将迭代器对象移向下一个位置\nIterator\u0026lt;String\u0026gt; it = list.iterator(); while(it.hasNext()){ String str = it.next(); System.out.println(str); } [!NOTE]\n报错NoSuchElementException 迭代器遍历完毕，指针不会复位（第二次遍历集合需重新获取iterator） 迭代器遍历时，不能用集合的方法进行增加或者删除 ，只能用it.remove() 增强for遍历 底层就是一个迭代器 修改增强for中的变量，不会改变集合中原本的数据 Collection\u0026lt;String\u0026gt; coll = new ArrayList\u0026lt;\u0026gt;(); for(String s : coll){ System.out.println(s); } lambda表达式遍历 coll.forEach(s -\u0026gt; System.out.println(s)); List 元素有序，可重复，有索引 add/remove List\u0026lt;String\u0026gt; L = new ArrayList\u0026lt;\u0026gt;(); L.add(\u0026#34;aaa\u0026#34;); L.add(\u0026#34;bbb\u0026#34;); L.add(\u0026#34;ccc\u0026#34;); L.add(1,\u0026#34;ddd\u0026#34;);//在指定位置插入元素，原位置以后的元素依次往后移 //aaa ddd bbb ccc String remove = L.remove(0);//aaa boolean remove = L.remove(\u0026#34;aaa\u0026#34;);//true [!NOTE] 当List存储对象为Integer时，使用remove(1),会优先删除索引为1的元素 由于 int 是基本数据类型，编译器会优先匹配参数类型最精确的方法\n解决方法：\n手动装箱list.remove(Integer.valueOf(1)); 向上转型list.remove((Object) 1); set/get set(int index,E element) 修改索引处的元素，返回修改前的元素\nget(int index)返回索引上的元素\n遍历方式 迭代器遍历 增强for遍历 lambda表达式遍历 普通for循环遍历 列表迭代器遍历 列表迭代器遍历 ListIterator\u0026lt;E\u0026gt; extends Iterator\u0026lt;E\u0026gt; 列表迭代器方法 add\u0026lt;E e\u0026gt;\nhasNext()\nnext()\nremove()\nhasPrevious()与hasNext()相反\nprevious()与next()相反\n在遍历的过程中可以添加元素\nListIterator\u0026lt;String\u0026gt; it = L.listIterator(); while(it.hasNext()){ if(\u0026#34;aaa\u0026#34;.equals(it.next())){ it.add(\u0026#34;qqq\u0026#34;); } //aaa qqq bbb ccc }\n![](image/08-3.png) ### ArrayList底层原理 - 底层是数组结构的 - 利用空参创建的集合，在底层创建一个默认长度为0得分数组 - 添加第一个元素，底层会创建一个新的==长度为10==的数组（elementData），初始化为null - 存满时，会扩容==1.5倍==（向下取整） - 如果一次添加多个元素，1.5倍放不下，则新创建数组的长度以实际为准。 ![](image/08-4.png) ```Java public boolean add(E e) { modCount++; add(e, elementData, size); return true; } private void add(E e, Object[] elementData, int s) { if (s == elementData.length) elementData = grow(); elementData[s] = e; size = s + 1; } private Object[] grow() { return grow(size + 1); } [!NOTE]\n对于if (oldCapacity \u0026gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) oldCapacity \u0026gt; 0 负责处理已经长大的数组； elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA 负责处理被用户手动指定为 0 的数组。 只有这两个条件都不满足（即：既是 0 又是默认空数组），才会触发“初始 10”的逻辑。 private Object[] grow(int minCapacity) { int oldCapacity = elementData.length; if (oldCapacity \u0026gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { int newCapacity = ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, /* minimum growth */ oldCapacity \u0026gt;\u0026gt; 1 /*默认新增容量*/); return elementData = Arrays.copyOf(elementData, newCapacity); } else { return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)]; } } public static int newLength(int oldLength, int minGrowth, int prefGrowth) { // 由于内嵌原因未勾选前提条件 // assert oldLength \u0026gt;= 0 // assert minGrowth \u0026gt; 0 int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // 可能会溢出来 if (0 \u0026lt; prefLength \u0026amp;\u0026amp; prefLength \u0026lt;= SOFT_MAX_ARRAY_LENGTH) { return prefLength; } else { // 用另一个方法冷处理代码 return hugeLength(oldLength, minGrowth); } } graph TD A[开始添加元素] --\u0026gt; B[modCount自增] B --\u0026gt; C{所需容量超过数组长度?} %% 扩容分支 C -- 是 --\u0026gt; D[调用grow方法] D --\u0026gt; E[计算新容量：旧容量1.5倍] E --\u0026gt; F{新容量满足最小需求?} F -- 否 --\u0026gt; G[新容量设为最小需求] G --\u0026gt; H[检查是否超JVM限制] F -- 是 --\u0026gt; H H --\u0026gt; I[迁移数据到新数组] I --\u0026gt; J[更新elementData引用] %% 插入分支 C -- 否 --\u0026gt; K[元素放入数组对应位置] J --\u0026gt; K K --\u0026gt; L[size自增] L --\u0026gt; M[返回true] M --\u0026gt; N[结束] LinkedList集合 底层数据结构是双链表，查询慢，增删快，但是如果操作的是首尾元素，速度也是极快 Iterator迭代器 modCount (Modification Count)： 属于 ArrayList 对象。只要列表结构发生变化（add, remove, clear 等），这个计数器就会 +1。\nexpectedModCount： 属于 Itr（迭代器）对象内部。在创建迭代器的那一刻，它会把当时的 modCount “拍照”存下来：expectedModCount = modCount\nSet 添加的元素无序，不重复，无索引 Set接口中的方法基本上与Collection一致（remove方法只能根据对象删除，不能根据索引删） HashSet 哈希表 JDK8之前：数组+链表 JDK8之后：数组+链表+红黑树 哈希值 应该存入的位置 int index = (数组长度 - 1) \u0026amp; 哈希值 该方法定义在Object类中，所有对象都可以调用，默认使用地址值进行计算 一般情况下，会重写hashCode方法，利用对象内部的属性值计算哈希值 对象哈希值的特点 如果没有重写hashCode方法，不同对象计算出的哈希值是不同的 如果已经重写hashCode方法，不同对象只要属性值相同，计算出的哈希值就是一样的 在小部分情况下，不同属性值或者不同的地址值计算出来的哈希值也有可能一样（哈希冲突） System.out.println(\u0026#34;abc\u0026#34;.hashCode()); //96354 System.out.println(\u0026#34;acD\u0026#34;.hashCode()); //96354 底层原理 先创建一个默认长度为16，默认 加载因子 为0.75的数组table 加载因子：存入第 16 * 0.75 = 12 个元素时，会触发扩容 0.75 是在频繁扩容的开销与查询延迟之间找到的黄金平衡点。 根据元素的哈希值跟数组长度计算出应存入的位置 判断当前的位置是否为null if null -\u0026gt; 存入 else -\u0026gt; 调用equals方法比较属性值 if true -\u0026gt; 不存 else -\u0026gt; 存入数组，形成链表 JDK8以前：新元素存入数组，老元素挂在新元素下面 JDK8之后：新元素直接挂在老元素下面 JDK8以后，当链表长度超过8，而且数组长度大于等于64时，自动转换为红黑树\n如果集合中存储的是自定义对象，必须要重写hashCode () 和equals () 方法(默认比较用的是地址值)\nHashSet的三个特点 HashSet为什么存和取的顺序不一样？ HashSet 存取顺序不一致，是因为它根据元素内容的 Hash 值经计算后直接存放在内部数组的随机位置，而非按时间先后排队； 读取时则是按数组下标从头到尾扫描，所以输出顺序取决于元素在内存中的分布位置，而非输入顺序 HashSet为什么没有索引？ HashSet 没有索引是因为它采用哈希表结构，元素是根据内容计算出的哈希值“随机”散落在数组位置上的，中间存在大量空位且位置会随扩容改变，这种非连续、非固定的存储方式使得通过物理位置（索引）定位元素变得毫无意义 HashSet是利用什么机制保证数据去重的？ HashSet 通过 hashCode() 快速定位存储位置，若位置冲突再利用 equals() 进行内容“肉搏”比对，只有当两个方法都判定相同时，才会触发去重机制拒绝存入。 LinkedHashSet 有序，不重复，无索引 这里的有序指的是保证存储和去除的元素顺序一致 原理：底层数据机构依然是哈希表，知识每个元素有额外多了一个==双链表==的机制记录存储的数据 如果要求去重且存取有序，则选择LinkedHashSet TreeSet 可排序，不重复，无索引 可排序：按照元素的默认规则（由小到大）排序 TreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好 TreeSet默认的规则 对于数值类型：Integer，Double，默认按照从小到大的顺序进行排序 对于字符、字符串类型：按照字符在ASCII码表中的数字升序进行排序 @Override public int compareTo(Student o) { return this.getAge()-o.getAge(); } this:表示当前要添加的元素 o :表示已经在红黑树存在的元素 返回值： 负数：认为要添加的元素是小的，存左边 正数：认为要添加的元素是大的，存右边 0：要添加的元素已存在，舍弃 TreeSet的两种比较方式 方式一 默认排序/自然排序：JavaBean类实现Comparable接口指定比较规则 方式二 比较器排序：创建TreeSet对象的时候，传递比较器Comparator制定规则 使用规则 默认使用第一种，如果第一种不能满足当前需求，就使用第二种 泛型 可以在编译阶段约束操作的数据类型，并进行检查 格式：\u0026lt;数据类型\u0026gt; 泛型只能支持引用数据类型 ==统一数据类型==，把运行时期的问题提前到了编译期间，避免了强制类型转化可能出现的异常 ==Java中的泛型是伪泛型== 注意！\n泛型中不能写基本数据类型 指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型 如果不写泛型，类型默认是Object 泛型类 public class MyArrayList\u0026lt;E\u0026gt;{ Object[] obj = new Object[10]; int size; public boolean add(E e){ obj[size++] = e; return true; } public E get(int index){ return (E)obj[index]; //存入ArrayList的数据都会变成Object } @Override public String toString(){ return Arrays.toString(obj); } } //此处的E可以理解为变量，但是不是用来记录数据的，是用来记录数据类型的,一般用：K、T、V、E 泛型方法 方法中形参不确定时 1.使用类名后面定义的泛型 -\u0026gt; 所有方法都能用 2.在方法申明上定义自己的泛型 -\u0026gt; 只有本方法能用 public \u0026lt;T\u0026gt; boid show(T t){ |此处的E可以理解为变量，但是不是用来记录数据的，是用来记录数据类型的,一般用：K、T、V、E| } public class ListUtil{ private ListUtil() {} /* * 参数一：集合 * 参数二：要添加的元素 * */ public static\u0026lt;E\u0026gt; void addAll(ArrayList\u0026lt;E\u0026gt; list,E...e){ for (E element : e) { list.add(element); } } } 泛型接口 实现类给出具体类型 public class MyArrayList implements List\u0026lt;String\u0026gt; { } 实现类延续泛型，创建对象时再确定 public class MyArrayList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt; { } 泛型的继承和通配符 ==泛型不具备继承性，但数据具备继承性== 通配符 \u0026lt;? extends E\u0026gt; 表示可以传递E或者E所有的子类类型 \u0026lt;? super E\u0026gt; 表示可以传递E或者E所有的父类类型 List与Set的使用场景 如果想要集合中的元素*可重复：\n用ArrayList集合，==基于数组的==（用的最多） 如果想要集合中的元素可重复，而且当前的增删操作明显多于查询：\n用LinkedList集合，==基于链表的== 如果想对集合中的元素去重：\n用HashSet，==基于哈希表的==（用的最多） 如果相对集合的元素去重，而且保证存取顺序\n用LinkedHashList集合，==基于哈希表和双链表，效率低于HashSet== Map ","date":"2026-02-03T00:00:00Z","permalink":"/hugo-blog/post/08-%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6/","title":"08-集合进阶"},{"content":" imageNameKey: \u0026ldquo;09\u0026rdquo; 栈Stack 后进先出，先进后出 压栈/进栈：数据进入栈模型的过程 弹栈/出栈：数据离开栈模型的过程 队列Queue 先进先出，后进后出 入队列：数据从后端进入队列模型的过程 出队列：数据从前端离开队列模型的过程 数组 ==查询速度快==：查询数据通过地址值和索引定位，查询任意数据耗时相同（元素在内存中是连续存储的） ==删除效率低==：要将原始数据删除，同时后面每个数据前移 ==添加效率低==：添加位置后的每个数据后移，再添加元素 链表 链表中的结点是独立的对象，在内存中是不连续的，每个节点包含数据值和下一个结点的地址 链表==查询慢==，无论查询哪个数据都从头开始找。 链表的==增删快==（对比数组） 树 [父节点地址值，值，左子节点地址值，右子节点地址值] 度：每一个节点的 子节点 数量 树高：树的总层数 10 \u0026lt;-- 根节点 / \\ 5 15 \u0026lt;-- 第二层 / \\ \\ 3 7 20 \u0026lt;-- 第三层 / 6 \u0026lt;-- 第四层 二叉树的遍历方式 前序遍历 从根节点开始，按照当前节点，左子节点，右子节点的顺序遍历 中序遍历 从最左边的子节点开始，然后按照左子节点，当前节点，右子节点的顺序遍历 后序遍历 从最右边的子节点开始，然后按照左子节点，右子节点，当前节点的顺序遍历 层序遍历 从根节点开始一层一层遍历 二叉查找树 每一个节点上最多有两个子节点 任意节点左子树上的值都小于当前节点 任意节点右子树上的值都大于当前节点 添加节点 小的存左边，大的存右边，一样的不存 弊端 左子树全部为空，从形式上看，更像一个==单链表== 插入速度没有影响 查询速度明显降低 解决弊端：平衡二叉树 平衡二叉树也叫 平衡二叉搜索树（Self-balancing binary search tree），又被称为 AVL 树，可以保证 查询效率较高。它是解决 二叉排序 可能出现的查询问题。\n二叉查找树 规则：==任意节点左右子树高度差不超过1== 保持平衡的旋转机制 左旋 右旋 当添加一个节点时，该树不再是一颗平衡二叉树 -\u0026gt; 旋转 左旋 确定支点：从添加的节点开始，不断的往父节点找不平衡的节点\n步骤：\n以不平衡的点作为支点 把支点左旋降级，变成左子节点 晋升 原来的右子节点 步骤： 以不平衡的点作为支点 将根节点的右侧往左拉 原先的右子节点变成新的父节点，并把多余的左子节点出让，给已经降级的根节点当右子节点 需要旋转的四种情况 左左LL 当==根结点左子树的左子树==有节点插入，导致二叉树不平衡 一次右旋 左右LR 当==根结点左子树的右子树==有节点插入，导致二叉树不平衡 先局部左旋 -\u0026gt; 左左LL 再整体右旋 右右RR 当==根结点右子树的右子树==有节点插入，导致二叉树不平衡 一次左旋 右左RL 当==根结点右子树的左子树==有节点插入，导致二叉树不平衡 先局部右旋 -\u0026gt; 右右RR 再整体左旋 红黑树 平衡二叉树的弊端：在添加节点的时候，旋转次数太多，造成添加节点的时间浪费 红黑树刚开始被称为平衡二叉B树 是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色 每一个节点可以是红或者黑；红黑树不是高度平衡的，他的平衡是通过“红黑规则“进行实现的 是一个二叉查找树 ==但是不是高度平衡的== 条件：特有的红黑规则 红黑规则 每一个节点是红色或黑色 根节点必须是黑色的 如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil被视为叶节点，每个叶节点 (Nil) 是黑色的 如果某一个节点是红色的，那么它的子节点必须是黑色（不能出现两个红色节点相连的情况） 对每一个节点，从该接待你到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点 添加节点 添加的节点默认是红色的（红色效率高） 查找、插入、删除的时间复杂度最坏为O(log n) ","date":"2026-02-03T00:00:00Z","permalink":"/hugo-blog/post/09-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"09-数据结构"},{"content":"Java笔记\n","date":"2026-02-03T00:00:00Z","permalink":"/hugo-blog/post/readme/","title":"README"}]